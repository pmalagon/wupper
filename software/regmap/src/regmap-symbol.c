/* *************************************************************************** */
/* *************************************************************************** */
/* *************************************************************************** */
/* *************************************************************************** */
/* *************************************************************************** */
/* DO NOT EDIT THIS FILE */
/*  */
/* This file was generated from template '../software/regmap/src/regmap-symbol.c.template' */
/* and register map registers-1.0.yaml, version 1.0 */
/* by the script 'wuppercodegen', version: 0.8.0, */
/* using the following commandline: */
/*  */
/* ../software/wuppercodegen/wuppercodegen/cli.py registers-1.0.yaml ../software/regmap/src/regmap-symbol.c.template ../software/regmap/src/regmap-symbol.c */
/*  */
/* Please do NOT edit this file, but edit the source file at '../software/regmap/src/regmap-symbol.c.template' */
/*  */
/* *************************************************************************** */
/* *************************************************************************** */
/* *************************************************************************** */
/* *************************************************************************** */
/* *************************************************************************** */


#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>

#include "regmap/regmap-symbol.h"


static
void regmap_str_upper(char *str)
{
  do
    {
      *str = toupper((unsigned char) *str);
    } while (*str++);
}


int
regmap_cfg_set_option(u_long offset, const char* key, u_long value)
{
  int result, found;
  char* upper;

  regmap_bitfield_t* bf;
  u_long* address;
  u_long mask;
  u_int shift;

  result = 0;

  upper = strdup(key);
  regmap_str_upper(upper);

  found = 0;

  for(bf=regmap_bitfields; bf->name != NULL; bf++) {
    if(0 == strcmp(upper, bf->name)) {
      found = 1;

      if(!(bf->flags & REGMAP_REG_WRITE)) {
        result = REGMAP_CFG_ERROR_NOT_WRITABLE;
        printf("Bitfield not writable!\n");
        break;
      }

      address = (u_long*)(offset + bf->address);
      mask = bf->mask;
      shift = bf->shift;
      /* zero the bits we're writing to... */
      *address &=~ mask;
      /* then OR the previous address with the value we're writing */
      *address |= (value << shift) & mask;
      break;
    }
  }

  if(!found) {
    result = REGMAP_CFG_ERROR_NO_EXIST;
    printf("Bitfield %s does not exist!\n", key);
  }

  free(upper);
  return result;
}

int
regmap_cfg_get_option(u_long offset, const char* key, u_long* value)
{
  int result, found;
  char* upper;

  regmap_bitfield_t* bf;
  u_long* address;
  u_long mask;
  u_int shift;

  result = 0;

  upper = strdup(key);
  regmap_str_upper(upper);

  found = 0;

  for(bf=regmap_bitfields; bf->name != NULL; bf++) {
    if(0 == strcmp(upper, bf->name)) {
      found = 1;

      if(!(bf->flags & REGMAP_REG_READ)) {
        result = REGMAP_CFG_ERROR_NOT_READABLE;
        printf("Bitfield not readable!\n");
        break;
      }

      address = (u_long*)(offset + bf->address);
      mask = bf->mask;
      shift = bf->shift;
      *value = (*address & mask) >> shift;
      break;
    }
  }

  if(!found) {
    result = REGMAP_CFG_ERROR_NO_EXIST;
    printf("Bitfield does not exist!\n");
  }

  free(upper);
  return result;
}

int
regmap_cfg_set_reg(u_long offset, const char* key, u_long value)
{
  int result, found;
  char* upper;

  regmap_register_t* reg;
  u_long* address;

  result = 0;

  upper = strdup(key);
  regmap_str_upper(upper);

  found = 0;

  for(reg=regmap_registers; reg->name != NULL; reg++) {
    if(0 == strcmp(upper, reg->name)) {
      found = 1;

      if(!(reg->flags & REGMAP_REG_WRITE)) {
        result = REGMAP_CFG_ERROR_NOT_WRITABLE;
        printf("Register not writable!\n");
        break;
      }

      address = (u_long*)(offset + reg->address);
      *address = value;
      break;
    }
  }

  if(!found) {
    result = REGMAP_CFG_ERROR_NO_EXIST;
    printf("Register %s does not exist!\n", key);
  }

  free(upper);
  return result;
}

int
regmap_cfg_get_reg(u_long offset, const char* key, u_long* value)
{
  int result, found;
  char* upper;

  regmap_register_t* reg;
  u_long* address;

  result = 0;

  upper = strdup(key);
  regmap_str_upper(upper);

  found = 0;

  for(reg=regmap_registers; reg->name != NULL; reg++) {
    if(0 == strcmp(upper, reg->name)) {
      found = 1;

      if(!(reg->flags & REGMAP_REG_READ)) {
        result = REGMAP_CFG_ERROR_NOT_READABLE;
        printf("Register not readable!\n");
        break;
      }

      address = (u_long*)(offset + reg->address);
      *value = *address;
      break;
    }
  }

  if(!found) {
    result = REGMAP_CFG_ERROR_NO_EXIST;
    printf("Register does not exist!\n");
  }

  free(upper);
  return result;
}

/* ================================ */
/* BELOW is ONLY generated CODE !   */
/* ================================ */
regmap_register_t regmap_registers[] =
  {
    /* Bar2 */
    /* GenericBoardInformation */
    { REG_REG_MAP_VERSION,
      "Full Register",
      0x00000,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { REG_BOARD_ID_TIMESTAMP,
      "Full Register",
      0x00010,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { REG_BOARD_ID_SVN,
      "Full Register",
      0x00020,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { REG_STATUS_LEDS,
      "Full Register",
      0x00030,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0
    },
    { REG_GENERIC_CONSTANTS,
      "Full Register",
      0x00040,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { REG_CARD_TYPE,
      "Full Register",
      0x00050,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    /* ApplicationSpecific */
    { REG_LFSR_SEED_0,
      "Full Register",
      0x01000,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1
    },
    { REG_LFSR_SEED_1,
      "Full Register",
      0x01010,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1
    },
    { REG_LFSR_SEED_2,
      "Full Register",
      0x01020,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1
    },
    { REG_LFSR_SEED_3,
      "Full Register",
      0x01030,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1
    },
    { REG_APP_MUX,
      "Full Register",
      0x01040,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1
    },
    { REG_LFSR_LOAD_SEED,
      "Full Register",
      0x01050,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1
    },
    { REG_APP_ENABLE,
      "Full Register",
      0x01060,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1
    },
    /* HouseKeepingControlsAndMonitors */
    { REG_MMCM_MAIN_PLL_LOCK,
      "Full Register",
      0x02300,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { REG_I2C_WR,
      "Full Register",
      0x02310,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0
    },
    { REG_I2C_RD,
      "Full Register",
      0x02320,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0
    },
    { REG_FPGA_CORE_TEMP,
      "Full Register",
      0x02330,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { REG_FPGA_CORE_VCCINT,
      "Full Register",
      0x02340,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { REG_FPGA_CORE_VCCAUX,
      "Full Register",
      0x02350,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { REG_FPGA_CORE_VCCBRAM,
      "Full Register",
      0x02360,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { REG_FPGA_DNA,
      "Full Register",
      0x02370,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1
    },
    { REG_INT_TEST_4,
      "Full Register",
      0x02800,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0
    },
    { REG_INT_TEST_5,
      "Full Register",
      0x02810,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0
    },
    /* Wishbone */
    { REG_WISHBONE_CONTROL,
      "Full Register",
      0x04000,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0
    },
    { REG_WISHBONE_WRITE,
      "Full Register",
      0x04010,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0
    },
    { REG_WISHBONE_READ,
      "Full Register",
      0x04020,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0
    },
    { REG_WISHBONE_STATUS,
      "Full Register",
      0x04030,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0
    },
    { NULL,
      NULL,
      0,
      0,
      0
    }
  };


regmap_bitfield_t regmap_bitfields[] =
  {
    /* Bar2 */
    /* GenericBoardInformation */
    { BF_REG_MAP_VERSION,
      "Register Map Version, 1.0 formatted as 0x0100",
      0x00000,
      0x000000000000FFFF,
      0,
      15,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_BOARD_ID_TIMESTAMP,
      "Board ID Date / Time in BCD format YYMMDDhhmm",
      0x00010,
      0x000000FFFFFFFFFF,
      0,
      39,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_BOARD_ID_SVN,
      "Board ID SVN Revision",
      0x00020,
      0x000000000000FFFF,
      0,
      15,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_STATUS_LEDS,
      "Board GPIO Leds",
      0x00030,
      0x00000000000000FF,
      0,
      7,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_GENERIC_CONSTANTS_INTERRUPTS,
      "Number of Interrupts",
      0x00040,
      0x000000000000FF00,
      8,
      15,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_GENERIC_CONSTANTS_DESCRIPTORS,
      "Number of Descriptors",
      0x00040,
      0x00000000000000FF,
      0,
      7,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_CARD_TYPE,
      "Card Type:\n  * 709 (0x2c5) VC709\n  * 710 (0x2c6) HTG710\n  * 711 (0x2c7) BNL711\n",
      0x00050,
      0xFFFFFFFFFFFFFFFF,
      0,
      63,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    /* ApplicationSpecific */
    { BF_LFSR_SEED_0,
      "Least significant 64 bits of the LFSR seed",
      0x01000,
      0xFFFFFFFFFFFFFFFF,
      0,
      63,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1      
    },
    { BF_LFSR_SEED_1,
      "Bits 127 downto 64 of the LFSR seed",
      0x01010,
      0xFFFFFFFFFFFFFFFF,
      0,
      63,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1      
    },
    { BF_LFSR_SEED_2,
      "Bits 191 downto 128 of the LFSR seed",
      0x01020,
      0xFFFFFFFFFFFFFFFF,
      0,
      63,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1      
    },
    { BF_LFSR_SEED_3,
      "Bits 255 downto 192 of the LFSR seed",
      0x01030,
      0xFFFFFFFFFFFFFFFF,
      0,
      63,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1      
    },
    { BF_APP_MUX,
      "Switch between multiplier or LFSR.\n  * 0 LFSR\n  * 1 Loopback\n",
      0x01040,
      0x0000000000000001,
      0,
      0,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1      
    },
    { BF_LFSR_LOAD_SEED,
      "Writing any value to this register triggers the LFSR module to reset to the LFSR_SEED value",
      0x01050,
      0x0000000000000000,
      0,
      -1,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1      
    },
    { BF_APP_ENABLE,
      "1 Enables LFSR module or Loopback (depending on APP_MUX)\n0 disable application\n",
      0x01060,
      0x0000000000000001,
      0,
      0,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1      
    },
    /* HouseKeepingControlsAndMonitors */
    { BF_MMCM_MAIN_PLL_LOCK,
      "Main MMCM PLL Lock Status",
      0x02300,
      0x0000000000000001,
      0,
      0,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_WR_I2C_WREN,
      "Any write to this register triggers an I2C read or write sequence",
      0x02310,
      0x0000000000000000,
      0,
      -1,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_WR_I2C_FULL,
      "I2C FIFO full",
      0x02310,
      0x0000000002000000,
      25,
      25,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_WR_WRITE_2BYTES,
      "Write two bytes",
      0x02310,
      0x0000000001000000,
      24,
      24,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_WR_DATA_BYTE2,
      "Data byte 2",
      0x02310,
      0x0000000000FF0000,
      16,
      23,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_WR_DATA_BYTE1,
      "Data byte 1",
      0x02310,
      0x000000000000FF00,
      8,
      15,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_WR_SLAVE_ADDRESS,
      "Slave address",
      0x02310,
      0x00000000000000FE,
      1,
      7,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_WR_READ_NOT_WRITE,
      "READ/<o>WRITE</o>",
      0x02310,
      0x0000000000000001,
      0,
      0,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_RD_I2C_RDEN,
      "Any write to this register pops the last I2C data from the FIFO",
      0x02320,
      0x0000000000000000,
      0,
      -1,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_RD_I2C_EMPTY,
      "I2C FIFO Empty",
      0x02320,
      0x0000000000000100,
      8,
      8,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_I2C_RD_I2C_DOUT,
      "I2C READ Data",
      0x02320,
      0x00000000000000FF,
      0,
      7,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_FPGA_CORE_TEMP,
      "XADC temperature monitor for the FPGA CORE\nfor Virtex7\ntemp (C)= ((FPGA_CORE_TEMP* 503.975)/4096)-273.15\nfor Kintex Ultrascale\ntemp (C)= ((FPGA_CORE_TEMP* 502.9098)/4096)-273.8195\n",
      0x02330,
      0x0000000000000FFF,
      0,
      11,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_FPGA_CORE_VCCINT,
      "XADC voltage measurement VCCINT = (FPGA_CORE_VCCINT *3.0)/4096",
      0x02340,
      0x0000000000000FFF,
      0,
      11,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_FPGA_CORE_VCCAUX,
      "XADC voltage measurement VCCAUX = (FPGA_CORE_VCCAUX *3.0)/4096",
      0x02350,
      0x0000000000000FFF,
      0,
      11,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_FPGA_CORE_VCCBRAM,
      "XADC voltage measurement VCCBRAM = (FPGA_CORE_VCCBRAM *3.0)/4096",
      0x02360,
      0x0000000000000FFF,
      0,
      11,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_FPGA_DNA,
      "Unique identifier of the FPGA",
      0x02370,
      0xFFFFFFFFFFFFFFFF,
      0,
      63,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0|REGMAP_ENDPOINT_1      
    },
    { BF_INT_TEST_4,
      "Fire a test MSIx interrupt #4",
      0x02800,
      0x0000000000000000,
      0,
      -1,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_INT_TEST_5,
      "Fire a test MSIx interrupt #5",
      0x02810,
      0x0000000000000000,
      0,
      -1,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    /* Wishbone */
    { BF_WISHBONE_CONTROL_WRITE_NOT_READ,
      "wishbone write command wishbone read command",
      0x04000,
      0x0000000100000000,
      32,
      32,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_CONTROL_ADDRESS,
      "Slave address for Wishbone bus",
      0x04000,
      0x00000000FFFFFFFF,
      0,
      31,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_WRITE_WRITE_ENABLE,
      "Any write to this register triggers a write to the Wupper to Wishbone fifo",
      0x04010,
      0x0000000000000000,
      0,
      -1,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_WRITE_FULL,
      "Wishbone",
      0x04010,
      0x0000000100000000,
      32,
      32,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_WRITE_DATA,
      "Wishbone",
      0x04010,
      0x00000000FFFFFFFF,
      0,
      31,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_READ_READ_ENABLE,
      "Any write to this register triggers a read from the Wishbone to Wupper fifo",
      0x04020,
      0x0000000000000000,
      0,
      -1,
      REGMAP_REG_READ|REGMAP_REG_WRITE,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_READ_EMPTY,
      "Indicates that the Wishbone to Wupper fifo is empty",
      0x04020,
      0x0000000100000000,
      32,
      32,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_READ_DATA,
      "Wishbone read data",
      0x04020,
      0x00000000FFFFFFFF,
      0,
      31,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_STATUS_INT,
      "interrupt",
      0x04030,
      0x0000000000000010,
      4,
      4,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_STATUS_RETRY,
      "Interface is not ready to accept data cycle should be retried",
      0x04030,
      0x0000000000000008,
      3,
      3,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_STATUS_STALL,
      "When pipelined mode slave can't accept additional transactions in its queue",
      0x04030,
      0x0000000000000004,
      2,
      2,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_STATUS_ACKNOWLEDGE,
      "Indicates the termination of a normal bus cycle",
      0x04030,
      0x0000000000000002,
      1,
      1,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { BF_WISHBONE_STATUS_ERROR,
      "Address not mapped by the crossbar",
      0x04030,
      0x0000000000000001,
      0,
      0,
      REGMAP_REG_READ,
      REGMAP_ENDPOINT_0      
    },
    { NULL,
      NULL,
      0,
      0,
      0,
      0,
      0,
      0
    }
  };


regmap_group_t regmap_groups[] =
  {
    /* GenericBoardInformation */
    { GRP_GEN,
      "Generic Board Information",
      { 0, 1, 2, 3, 4, 5, -1 }
    },
    /* ApplicationSpecific */
    { GRP_APP,
      "Application specific registers",
      { 6, 7, 8, 9, 10, 11, 12, -1 }
    },
    /* HouseKeepingControlsAndMonitors */
    { GRP_HKC,
      "House Keeping Controls and Monitors",
      { 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
 23, 24, 25, 26, -1 }
    },
    { NULL,
      NULL,
      { -1 }
    }
  };