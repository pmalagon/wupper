%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional\else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{geometry}
\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{WUPPER Code Generator Documentation}
\date{Oct 22, 2017}
\release{0.6.2}
\author{Mark D\"onszelmann, Jose Valenciano, J\"orn Schumacher}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


The Wupper Code Generator is a tool to generate various files used for the
implementation of configuration mechanism of the FELIX interface card
firmware. Files that can be generated include:
\begin{itemize}
\item {} 
A VHDL description of configuration parameters with
required datatypes (e.g., a list of VHDL record types).

\item {} 
A VHDL file for a register mapping, which relates parameter
register to PCIe addresses. This can include write- and read-processes
for all configuration registers.

\item {} 
A matching C header file, which matches the register mapping described
in the previous point to C datastructures which represent the different
configuration options.

\item {} 
A (partial) OKS schema for the firmware parameters. This still needs to
be extended with an OKS schema for the software configuration options. It
is yet to be determined how much of the H/W OKS schema can be autogenerated,
as not all parameters of the firmware should be configurable using an OKS database.

\item {} 
Other use cases are thinkable, e.g., automatic documentation of the parameters,
registers, datatypes, etc.

\end{itemize}

The Wupper Code Generator tool uses two kinds of inputs:
\begin{itemize}
\item {} 
A configuration file describing all configuration registers of the firmware, as well
their data types, default values, and other relevant information.
The format of the input file is YAML.

\item {} 
A (set of) template file(s), describing how the output of the tool should
look like. \sphinxhref{http://jinja.pocoo.org/}{Jinja2} is used as template engine.

\end{itemize}

Additionally, the tool automatically generates a unique address for each
register. This can be used to assign individual registers to addresses
in the PCI memory mapping.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{WUPPER_Code_Generator_Tool}.png}\hspace*{\fill}}


\chapter{Contents}
\label{\detokenize{index:the-wupper-code-generator}}\label{\detokenize{index:contents}}

\section{Installation}
\label{\detokenize{installation:installation}}\label{\detokenize{installation::doc}}
WupperCodeGen is written in Python and was tested with versions 2.6 and 2.7.
Additionally, you will need to install the Jinja2 template engine and the
Python Yaml parser. In case of Python 2.6 you will have to install the
argparse module as well.


\subsection{Installation from PyPI using pip}
\label{\detokenize{installation:installation-from-pypi-using-pip}}
Installation using pip, which will install all dependencies:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{wuppercodegen}
\end{sphinxVerbatim}


\subsection{Scientific Linux and RedHat-based distributions}
\label{\detokenize{installation:scientific-linux-and-redhat-based-distributions}}
Installation of system-wide Jinja2 in SLC6:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{yum} \PYG{n}{install} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{jinja2} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{argparse} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{yaml} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{markupsafe}
\end{sphinxVerbatim}


\subsection{Ubuntu}
\label{\detokenize{installation:ubuntu}}
Installation of system-wide Jinja2 in Ubuntu:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{jinja2} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{yaml} \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{markupsafe}
\end{sphinxVerbatim}


\subsection{Using Virtual Python Environments}
\label{\detokenize{installation:using-virtual-python-environments}}
This method allows to install the necessary dependencies in an isolated Python
environment, without affecting system packages. The method described here is
independent of the operating system being used, as long as it is used with
a supported version of Python.

Installation in a virtual environment:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} create the virtual environment}
\PYG{n}{virtualenv} \PYG{n}{venv}\PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{python}\PYG{o}{=}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{python26}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{or}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{27}

\PYG{c+c1}{\PYGZsh{} activate the virtual environment}
\PYG{n}{source} \PYG{n}{venv}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{activate}

\PYG{c+c1}{\PYGZsh{} install Jinja2 ad other modules}
      \PYG{n}{pip} \PYG{n}{install} \PYG{n}{Jinja2}
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{argparse}
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{PyYAML}
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{MarkupSafe}

\PYG{c+c1}{\PYGZsh{} you can now use WupperCodeGen}
\PYG{c+c1}{\PYGZsh{} the virtual environment can be deactivated with}
\PYG{n}{source} \PYG{n}{venv}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{deactivate}
\end{sphinxVerbatim}


\section{User Documentation}
\label{\detokenize{user::doc}}\label{\detokenize{user:user-documentation}}

\subsection{Command Line Interface}
\label{\detokenize{user:command-line-interface}}
A Makefile is provided that calls WupperCodeGen with the correct parameters to
generate the output files. A simple \sphinxcode{make} in the WupperCodeGen directory is
enough to produce the output, which is stored in the directory `output'.

If there is a need to do so, the tool can be called manually in the following way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{wuppercodegen} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{version}\PYG{p}{]} \PYG{n}{config\PYGZus{}file} \PYG{n}{template\PYGZus{}file} \PYG{n}{output\PYGZus{}file}
\end{sphinxVerbatim}

The following parameters have to be set:
\begin{description}
\item[{\sphinxcode{config\_file}}] \leavevmode
An input file containing a description of all configuration registers and
grouping thereof in YAML format.

\item[{\sphinxcode{template\_file}}] \leavevmode
A Jinja2 template file, used to describe the output file.

\item[{\sphinxcode{output\_file}}] \leavevmode
The filename of the output file that is to be generated.

\end{description}


\subsection{Input Files}
\label{\detokenize{user:input-files}}
Input files are located in the current directory. There are two types of input files:
\begin{itemize}
\item {} 
data files, containing a description of the desired bitfields, registers and groups in YAML format,

\item {} 
template files, describing how the generated code should look like.

\end{itemize}

Users normally only deal with the YAML file.

The Register Description File is a YAML (`registers.yaml') file containing a
description of Groups, Registers and Bitfields. The top-level group is named
`Registers'. Groups are named, and
may contain other Groups and or Registers. Groups can be repeated to create
a Sequence of Groups/Registers. Registers are also named and contain one or more
Bitfields. Bitfields are named if there are more than one.
Groups, Registers and BitFields are commonly referred to as Nodes. Below a
description of each of these types:


\subsubsection{Group}
\label{\detokenize{user:group}}
Groups are declared in yaml by their name, followed by a number of key-value
pairs, referred to as attributes. The only obliged attribute is `entries' which
lists all the subgroups or registers contained in this group. `entries' is a
list. The top-level group is called `Registers', all other groups can have
any name, but it needs to be unique.

Subgroups are declared just like groups
and referred to by name in the `entries' array under the key `ref'. A group that
needs repeating may contain the key `number', which is added as a index-parameter
in the lookup of the subgroup, and used in the name of its registers, see under registers.
Below is group example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+lScalar+lScalarPlain}{Registers}\PYG{p+pIndicator}{:}
  \PYG{l+lScalar+lScalarPlain}{type}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{R}
  \PYG{l+lScalar+lScalarPlain}{step}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{0x010}
  \PYG{l+lScalar+lScalarPlain}{default}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{0}
  \PYG{l+lScalar+lScalarPlain}{entries}\PYG{p+pIndicator}{:}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{ref}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{Bar0}
      \PYG{l+lScalar+lScalarPlain}{offset}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{0x0000}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{ref}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{Bar1}
      \PYG{l+lScalar+lScalarPlain}{offset}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{0x0000}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{ref}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{Bar2}
      \PYG{l+lScalar+lScalarPlain}{offset}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{0x0000}

\PYG{l+lScalar+lScalarPlain}{Bar0}\PYG{p+pIndicator}{:}
  \PYG{l+lScalar+lScalarPlain}{entries}\PYG{p+pIndicator}{:}
\PYG{n+nn}{...}
\end{sphinxVerbatim}


\subsubsection{Register and Bitfields}
\label{\detokenize{user:register-and-bitfields}}
Registers are declared directly inside the `entries' attribute of a group. They
need a `name' and a `bitfield' attribute. Bitfield is in fact a list of one or
more bitfields, which must contain `range' as attribute and `name',
if there is more than one bitfield in the list. Range is given as a single bit
or as a range of high to low bits (both included in the range).

Below is a register and bitfield example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+lScalar+lScalarPlain}{GenericBoardInformation}\PYG{p+pIndicator}{:}
  \PYG{l+lScalar+lScalarPlain}{entries}\PYG{p+pIndicator}{:}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{name}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{BOARD\PYGZus{}ID}
      \PYG{l+lScalar+lScalarPlain}{bitfield}\PYG{p+pIndicator}{:}
        \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{range}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{79..64}
          \PYG{l+lScalar+lScalarPlain}{name}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{SVN}
          \PYG{l+lScalar+lScalarPlain}{desc}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{Build}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{SVN}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{Revision}
        \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{range}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{39..0}
          \PYG{l+lScalar+lScalarPlain}{name}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{BUILD}
          \PYG{l+lScalar+lScalarPlain}{desc}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{Build}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{Date}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{/}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{Time}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{in}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{BCD}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{format}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{YYMMDDhhmm}

    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{name}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{STATUS\PYGZus{}LEDS}
      \PYG{l+lScalar+lScalarPlain}{type}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{W}
      \PYG{l+lScalar+lScalarPlain}{bitfield}\PYG{p+pIndicator}{:}
        \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{range}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{7..0}
          \PYG{l+lScalar+lScalarPlain}{default}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{0xAB}
          \PYG{l+lScalar+lScalarPlain}{desc}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{Board}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{GPIO}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{Leds}

\PYG{n+nn}{...}
\end{sphinxVerbatim}

The name attribute of a register
may contain one \% operator to use the repeat-index-parameter to give repeated registers
a unique name.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+lScalar+lScalarPlain}{Bar1}\PYG{p+pIndicator}{:}
  \PYG{l+lScalar+lScalarPlain}{entries}\PYG{p+pIndicator}{:}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{ref}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{INT\PYGZus{}VEC}
      \PYG{l+lScalar+lScalarPlain}{number}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{8}
\PYG{n+nn}{...}

\PYG{l+lScalar+lScalarPlain}{INT\PYGZus{}VEC}\PYG{p+pIndicator}{:}
  \PYG{l+lScalar+lScalarPlain}{entries}\PYG{p+pIndicator}{:}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{name}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{INT\PYGZus{}VEC\PYGZus{}\PYGZpc{}01d}
\PYG{n+nn}{...}
\end{sphinxVerbatim}


\subsubsection{Attributes}
\label{\detokenize{user:attributes}}
Attributes in Bitfields, Registers and Groups are inherited, which means that
if you set them on a group, all sub-groups, sequences, registers and bitfield inherit them.
This way you can set defaults for a particular group.
The following attributes do NOT inherit: `name', `full\_name', `offset', `address',
`index', `entries', `number', `ref',
`is\_bitfield', `is\_register', `is\_group'.

The following attributes are used/available:
\begin{description}
\item[{name (not inherited)}] \leavevmode
The name of the bitfield, group or register. The name may include fields such as
\{index\} for sequences and \{bitfield\} for bitfield names.

\item[{full\_name (not inherited)}] \leavevmode\begin{itemize}
\item {} 
For Sequences, the formatted name of the sequence name and the index, if the
sequence name includes \{index\}.

\item {} 
For Registers, the formatted name of the register name and the index, if the
register name includes \{index\}.

\item {} 
For Bitfields, the formatted name of the parent register and the bitfield name
if the register name includes \{bitfield\}. The bitfield part is separated from
the name by an underscore.
Bitfields of which the parent register is part of a sequence may use also
\{index\} in the parent register's name to format that name.

\end{itemize}

\item[{dot\_name (not inherited)}] \leavevmode\begin{itemize}
\item {} 
For Bitfields only, separating the bitfield part from the name by a dot.

\end{itemize}

\item[{prefix\_name (not inherited)}] \leavevmode\begin{itemize}
\item {} 
For Registers only, the part of the name without the \{bitfield\} specifier.
To be used if you just want the generic name of the register.

\end{itemize}

\item[{desc}] \leavevmode
A description of the register or bitfield. The `\textbar{}' operator can be used
for multi-line descriptions, which if used as end-of-line comments in the
template will properly format.

\item[{type}] \leavevmode
The type of register/bitfield, which can be R: read-only, W: read/write or
T: trigger (any write results in something happening, e.g. reset...)

\item[{default}] \leavevmode
The default value to be used to initialize the register or bitfield.
Default can be given as an array, if needed. All fields should be supplied, for example
a 6 entry array {[}0..5{]}:

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+lScalar+lScalarPlain}{default}\PYG{p+pIndicator}{:}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{0x00000124aaaa8006}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{0x00000124aaaa8078}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{0x00000124aaaa8001}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{0x00000124aaaaff80}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{0x00000124aaaae628}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{0x00000124aaaa99d0}
\end{sphinxVerbatim}
\begin{description}
\item[{value}] \leavevmode
Value (or string) to be used for Trigger registers.

\item[{offset (not inherited)}] \leavevmode
Sets the offset used for a register or group.

\item[{address (not inherited, calculated)}] \leavevmode
Address is a calculated value. It starts at 0 for the top-level group.
The `offset' attribute gets added to the address of a group to create
the current address. Sub-groups and registers are located at the current
address. The current address is incremented by `step' for every register.
One can place any register or group at a particular address by calculating
the needed offset from the address of the parent group.

\item[{step}] \leavevmode
The address increase added to offset for every register.

\item[{entries (not inherited)}] \leavevmode
A list of registers or references to sub-groups.

\item[{ref (not inherited)}] \leavevmode
A reference (by name) to a sub-group.

\item[{number (not inherited)}] \leavevmode
Number of times a referred group needs to be repeated in a sequence.

\item[{index (not inherited)}] \leavevmode
The index for this group or register inside a sequence.

\item[{bitfield}] \leavevmode
List of (at least one) bitfields describing the bits in a register.

\item[{range}] \leavevmode
The bit range (even single bit) of a bitfield. Ranges can be expressed as
single integers, as a high..low range, or with the word `any'.

\item[{\sphinxstyleemphasis{any other}}] \leavevmode
The value given, inherited from group to group to register to bitfield.

\end{description}


\subsubsection{Metadata}
\label{\detokenize{user:metadata}}
You can use the following metadata which is available in the Metadata dictionary:
\begin{description}
\item[{version}] \leavevmode
The version of WupperCodeGen

\item[{name:}] \leavevmode
The name of WupperCodeGen

\item[{exec:}] \leavevmode
The program executed

\item[{config:}] \leavevmode
The path of the config file

\item[{template:}] \leavevmode
The path of the template file

\item[{output:}] \leavevmode
The path of the output file

\item[{cmdline:}] \leavevmode
The full command line

\end{description}

Each of these can used inside the config file or in the template. Care must be
taken when the output is in LaTeX as the codes change for LaTeX, so any variable
in the config file (the template file is already coded for LaTeX) must be filtered
through the tex\_yaml\_encode filter.

Below an example of setting up a warning how the output file is generated:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+lScalar+lScalarPlain}{Registers}\PYG{p+pIndicator}{:}
  \PYG{l+lScalar+lScalarPlain}{version}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{1.3.0}
  \PYG{l+lScalar+lScalarPlain}{warning}\PYG{p+pIndicator}{:} \PYG{p+pIndicator}{\textbar{}}
    \PYG{n+no}{This file was generated from \PYGZsq{}\PYGZob{}\PYGZob{} metadata.template \PYGZcb{}\PYGZcb{}\PYGZsq{}, version \PYGZob{}\PYGZob{} tree.version \PYGZcb{}\PYGZcb{}}
    \PYG{n+no}{by the script \PYGZsq{}\PYGZob{}\PYGZob{} metadata.name \PYGZcb{}\PYGZcb{}\PYGZsq{}, version: \PYGZob{}\PYGZob{} metadata.version \PYGZcb{}\PYGZcb{}, using the following commandline:}

    \PYG{n+no}{\PYGZob{}\PYGZob{} metadata.cmdline \PYGZcb{}\PYGZcb{}}

    \PYG{n+no}{Please do NOT edit this file, but edit the source file at \PYGZsq{}\PYGZob{}\PYGZob{} metadata.template \PYGZcb{}\PYGZcb{}\PYGZsq{}}

  \PYG{l+lScalar+lScalarPlain}{entries}\PYG{p+pIndicator}{:}
    \PYG{l+lScalar+lScalarPlain}{...}
\end{sphinxVerbatim}

and the usage in a LaTeX the template

\begin{sphinxVerbatim}[commandchars=\\\{\}]
((( tree.warning\textbar{}tex\PYG{n+nb}{\PYGZus{}}yaml\PYG{n+nb}{\PYGZus{}}encode\textbar{}tex\PYG{n+nb}{\PYGZus{}}comment )))
...
\end{sphinxVerbatim}

and its output

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZpc{} This file was generated from \PYGZsq{}warning.tex.template\PYGZsq{}, version 1.3.0}
\PYG{c}{\PYGZpc{} by the script \PYGZsq{}WupperCodeGen\PYGZsq{}, version: 0.3, using the following commandline:}
\PYG{c}{\PYGZpc{}}
\PYG{c}{\PYGZpc{} ../wupper\PYGZus{}codegen.py warning.yaml warning.tex.template warning.tex}
\PYG{c}{\PYGZpc{}}
\PYG{c}{\PYGZpc{} Please do NOT edit this file, but edit the source file at \PYGZsq{}warning.txt.template\PYGZsq{}}
...
\end{sphinxVerbatim}


\section{Developer Documentation}
\label{\detokenize{developer:developer-documentation}}\label{\detokenize{developer::doc}}
Developers manage the code generated by WupperCodeGen. The output is defined by
Jinja2 template files, usually ending in `.template'.


\subsection{Template Files}
\label{\detokenize{developer:template-files}}
The template files should be written using \sphinxhref{http://jinja.pocoo.org/}{Jinja2}
syntax. Jinja2 statements can be either flow control commands such as \sphinxcode{\{\% for g
in groups \%\}} or simple text substitutions such as \sphinxcode{\{\{ g.name \}\}}. For a
detailed description of the Jinja2 language, please refer to the \sphinxhref{http://jinja.pocoo.org/docs/dev/}{official
documentation}, but look below for the
special codes to use for LaTeX templates.

The data retrieved from the input file (yaml) is available as variables in the
template. Those variables are listed in the user documentation. Apart from these
variables one may call a number of functions and filters as explained below.

\sphinxstyleemphasis{The following global variables are available:}
\begin{description}
\item[{metadata}] \leavevmode
A dictionary with some metadata, available for the config file and the template.

\item[{tree}] \leavevmode
The root of all the nodes, e.g. the one named `Registers'.

\item[{registers}] \leavevmode
A list of all the registers. All registers are linked into the tree by
their `parent' attribute.

\item[{nodes}] \leavevmode
A lookup table of all nodes, stored by name or full\_name. All nodes are linked
into the tree by their `parent' attribute.

\end{description}

In case wuppercodegen is called in \sphinxquotedblleft{}diff\sphinxquotedblright{} mode you also have access to the following global variables:
\begin{description}
\item[{diff\_tree}] \leavevmode
The root of all the nodes from the diff file, e.g. the one named `Registers'.

\item[{diff\_registers}] \leavevmode
A list of all the registers from the diff file. All registers are linked into the diff\_tree by
their `parent' attribute.

\item[{diff\_nodes}] \leavevmode
A lookup table of all nodes from the diff file, stored by name or full\_name. All nodes are linked
into the diff\_tree by their `parent' attribute.

\item[{changed\_registers}] \leavevmode
A list of changed registers.

\end{description}


\subsection{Functions}
\label{\detokenize{developer:functions}}
All functions of Node can be called on BitField, Register, Group or Sequence.
These themselves have extra functions available as well.
Functions without arguments can be called as if they were attributes (no parentheses).
\phantomsection\label{\detokenize{developer:module-wuppercodegen.classes}}\index{wuppercodegen.classes (module)}
Classes.
\index{Node (class in wuppercodegen.classes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{wuppercodegen.classes.}\sphinxbfcode{Node}}{\emph{parent}, \emph{dictionary}, \emph{name}}{}
Bases: \sphinxcode{object}

Root object of BitField, Register, Group and Sequence.
\index{full\_name() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.full_name}}\pysiglinewithargsret{\sphinxbfcode{full\_name}}{}{}
Return `print\_name' if `format\_name' is defined, otherwise it returns `name'.

\end{fulllineitems}

\index{has\_endpoint() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.has_endpoint}}\pysiglinewithargsret{\sphinxbfcode{has\_endpoint}}{\emph{endpoint}}{}
Return if endpoint is supported.

\end{fulllineitems}

\index{has\_groupname() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.has_groupname}}\pysiglinewithargsret{\sphinxbfcode{has\_groupname}}{}{}
Return True if group (not sequence) and `group' is defined for a groupname.

\end{fulllineitems}

\index{has\_read\_bitfields() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.has_read_bitfields}}\pysiglinewithargsret{\sphinxbfcode{has\_read\_bitfields}}{}{}
Return True if a register has any read bitfields.

\end{fulllineitems}

\index{has\_trigger\_bitfields() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.has_trigger_bitfields}}\pysiglinewithargsret{\sphinxbfcode{has\_trigger\_bitfields}}{}{}
Return True if a register has any trigger bitfields.

\end{fulllineitems}

\index{has\_write\_bitfields() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.has_write_bitfields}}\pysiglinewithargsret{\sphinxbfcode{has\_write\_bitfields}}{}{}
Return True if a register has any write bitfields.

\end{fulllineitems}

\index{is\_bitfield (wuppercodegen.classes.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.is_bitfield}}\pysigline{\sphinxbfcode{is\_bitfield}\sphinxstrong{ = False}}
True is node is a bitfield.

\end{fulllineitems}

\index{is\_group (wuppercodegen.classes.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.is_group}}\pysigline{\sphinxbfcode{is\_group}\sphinxstrong{ = False}}
True if node is a group.

\end{fulllineitems}

\index{is\_read() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.is_read}}\pysiglinewithargsret{\sphinxbfcode{is\_read}}{}{}
Return True if a group, register or bitfield is readable.

\end{fulllineitems}

\index{is\_register (wuppercodegen.classes.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.is_register}}\pysigline{\sphinxbfcode{is\_register}\sphinxstrong{ = False}}
True if node is a register.

\end{fulllineitems}

\index{is\_sequence (wuppercodegen.classes.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.is_sequence}}\pysigline{\sphinxbfcode{is\_sequence}\sphinxstrong{ = False}}
True if node is a sequence. Sequences are also groups.

\end{fulllineitems}

\index{is\_trigger() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.is_trigger}}\pysiglinewithargsret{\sphinxbfcode{is\_trigger}}{}{}
Return True if a group, register or bitfield is triggerable.

\end{fulllineitems}

\index{is\_write() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.is_write}}\pysiglinewithargsret{\sphinxbfcode{is\_write}}{}{}
Return True if a group, register or bitfield is writeable.

\end{fulllineitems}

\index{print\_name() (wuppercodegen.classes.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Node.print_name}}\pysiglinewithargsret{\sphinxbfcode{print\_name}}{}{}
Return formatted name according to `format\_name', using `index', `name' and `parent.print\_name'.

\end{fulllineitems}


\end{fulllineitems}

\index{BitField (class in wuppercodegen.classes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.BitField}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{wuppercodegen.classes.}\sphinxbfcode{BitField}}{\emph{parent}, \emph{dictionary}, \emph{name}}{}
Bases: {\hyperref[\detokenize{developer:wuppercodegen.classes.Node}]{\sphinxcrossref{\sphinxcode{wuppercodegen.classes.Node}}}}

Bitfield, defines specifics about bits inside the register.
\index{bits() (wuppercodegen.classes.BitField method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.BitField.bits}}\pysiglinewithargsret{\sphinxbfcode{bits}}{}{}
The number of bits in the bitfield range. Returns 0 if the range is `any'.

\end{fulllineitems}

\index{dot\_name() (wuppercodegen.classes.BitField method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.BitField.dot_name}}\pysiglinewithargsret{\sphinxbfcode{dot\_name}}{}{}
Return register name with bitfield name appended with a `.'.

\end{fulllineitems}

\index{full\_name() (wuppercodegen.classes.BitField method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.BitField.full_name}}\pysiglinewithargsret{\sphinxbfcode{full\_name}}{}{}
Return `print\_name' if `format\_name' is defined, otherwise appends bitfield `name' with underscore to `name'.

\end{fulllineitems}

\index{hi() (wuppercodegen.classes.BitField method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.BitField.hi}}\pysiglinewithargsret{\sphinxbfcode{hi}}{}{}
The highest bit in the bitfield range. Returns 0 if the range is `any'.

\end{fulllineitems}

\index{lo() (wuppercodegen.classes.BitField method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.BitField.lo}}\pysiglinewithargsret{\sphinxbfcode{lo}}{}{}
The lowest bit in the bitfield range. Returns -1 if the range is `any'.

\end{fulllineitems}

\index{print\_name() (wuppercodegen.classes.BitField method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.BitField.print_name}}\pysiglinewithargsret{\sphinxbfcode{print\_name}}{}{}
Return formatted name according to `format\_name', using `index', `name' and `parent.print\_name'.

\end{fulllineitems}

\index{value\_string() (wuppercodegen.classes.BitField method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.BitField.value_string}}\pysiglinewithargsret{\sphinxbfcode{value\_string}}{}{}
Return value indexed if needed.

\end{fulllineitems}


\end{fulllineitems}

\index{Entry (class in wuppercodegen.classes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Entry}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{wuppercodegen.classes.}\sphinxbfcode{Entry}}{\emph{parent}, \emph{dictionary}, \emph{name}, \emph{index}}{}
Bases: {\hyperref[\detokenize{developer:wuppercodegen.classes.Node}]{\sphinxcrossref{\sphinxcode{wuppercodegen.classes.Node}}}}

Allows to be an entry in a sequence.
\index{index (wuppercodegen.classes.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Entry.index}}\pysigline{\sphinxbfcode{index}\sphinxstrong{ = None}}
Index if part of a sequence

\end{fulllineitems}

\index{size() (wuppercodegen.classes.Entry method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Entry.size}}\pysiglinewithargsret{\sphinxbfcode{size}}{}{}
Return the size in bytes of the Register, Group or Sequence.

\end{fulllineitems}


\end{fulllineitems}

\index{Register (class in wuppercodegen.classes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Register}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{wuppercodegen.classes.}\sphinxbfcode{Register}}{\emph{parent}, \emph{dictionary}, \emph{name}, \emph{index}}{}
Bases: {\hyperref[\detokenize{developer:wuppercodegen.classes.Entry}]{\sphinxcrossref{\sphinxcode{wuppercodegen.classes.Entry}}}}

Register.
\index{bits() (wuppercodegen.classes.Register method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Register.bits}}\pysiglinewithargsret{\sphinxbfcode{bits}}{}{}
The number of bits in the bitfield range. Returns 0 if the range is `any'.

\end{fulllineitems}

\index{full\_name() (wuppercodegen.classes.Register method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Register.full_name}}\pysiglinewithargsret{\sphinxbfcode{full\_name}}{}{}
Return `print\_name' if `format\_name' is defined, otherwise returns `name' formatted with `index' if defined.

\end{fulllineitems}

\index{hi() (wuppercodegen.classes.Register method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Register.hi}}\pysiglinewithargsret{\sphinxbfcode{hi}}{}{}
Return the highest of all bitfield ranges.

\end{fulllineitems}

\index{lo() (wuppercodegen.classes.Register method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Register.lo}}\pysiglinewithargsret{\sphinxbfcode{lo}}{}{}
Return the lowest of all bitfield ranges.

\end{fulllineitems}

\index{prefix\_name() (wuppercodegen.classes.Register method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Register.prefix_name}}\pysiglinewithargsret{\sphinxbfcode{prefix\_name}}{}{}
Return `full\_name' without the \{bitfield\} part.

\end{fulllineitems}

\index{size() (wuppercodegen.classes.Register method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Register.size}}\pysiglinewithargsret{\sphinxbfcode{size}}{}{}
TBD.

\end{fulllineitems}

\index{sort\_by\_address() (wuppercodegen.classes.Register method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Register.sort_by_address}}\pysiglinewithargsret{\sphinxbfcode{sort\_by\_address}}{}{}
TBD.

\end{fulllineitems}


\end{fulllineitems}

\index{Group (class in wuppercodegen.classes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Group}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{wuppercodegen.classes.}\sphinxbfcode{Group}}{\emph{parent}, \emph{dictionary}, \emph{name}, \emph{index}}{}
Bases: {\hyperref[\detokenize{developer:wuppercodegen.classes.Entry}]{\sphinxcrossref{\sphinxcode{wuppercodegen.classes.Entry}}}}

Groups a number of registers.
\index{size() (wuppercodegen.classes.Group method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Group.size}}\pysiglinewithargsret{\sphinxbfcode{size}}{}{}
TBD.

\end{fulllineitems}


\end{fulllineitems}

\index{Sequence (class in wuppercodegen.classes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Sequence}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{wuppercodegen.classes.}\sphinxbfcode{Sequence}}{\emph{parent}, \emph{dictionary}, \emph{name}, \emph{number}, \emph{index}}{}
Bases: {\hyperref[\detokenize{developer:wuppercodegen.classes.Group}]{\sphinxcrossref{\sphinxcode{wuppercodegen.classes.Group}}}}

Array of registers.
\index{full\_name() (wuppercodegen.classes.Sequence method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Sequence.full_name}}\pysiglinewithargsret{\sphinxbfcode{full\_name}}{}{}
Return name, formatted by index if defined.

\end{fulllineitems}

\index{number (wuppercodegen.classes.Sequence attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.classes.Sequence.number}}\pysigline{\sphinxbfcode{number}\sphinxstrong{ = None}}
Size of the sequence

\end{fulllineitems}


\end{fulllineitems}



\subsection{Tests}
\label{\detokenize{developer:tests}}
Tests can be called if output is based on some condition.
\phantomsection\label{\detokenize{developer:module-wuppercodegen.test}}\index{wuppercodegen.test (module)}
Tests.
\index{in\_group() (in module wuppercodegen.test)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.test.in_group}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.test.}\sphinxbfcode{in\_group}}{\emph{node}, \emph{name}}{}
Return True if this bitfield, register, group or sequence belongs to `group'.

\end{fulllineitems}



\subsection{Filters}
\label{\detokenize{developer:filters}}
Filters are used to modify input (with or without parameters). They are handy for
formatting and aligning the output.
\phantomsection\label{\detokenize{developer:module-wuppercodegen.filter}}\index{wuppercodegen.filter (module)}
Filters.
\index{append() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.append}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{append}}{\emph{value}, \emph{postfix}}{}
Format the input value as \sphinxstyleemphasis{value}postfix.

\end{fulllineitems}

\index{c\_comment() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.c_comment}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{c\_comment}}{\emph{value}, \emph{indent=0}}{}
Split the input value in separate lines and indents each of them by `indent' spaces.

Every line is surrounded by a c comment delimiter (/* ... */).

\end{fulllineitems}

\index{c\_hex() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.c_hex}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{c\_hex}}{\emph{value}, \emph{digits=4}}{}
Format the input value as hexadecimal: 0x1F40.

\end{fulllineitems}

\index{c\_mask() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.c_mask}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{c\_mask}}{\emph{bitfield}}{}
Return the mask value based on the bitfield.hi and bitfield.lo values.

\end{fulllineitems}

\index{c\_string() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.c_string}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{c\_string}}{\emph{value}}{}
Escape YAML (multi-line) string into a C string.

\end{fulllineitems}

\index{camel\_case\_to\_space() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.camel_case_to_space}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{camel\_case\_to\_space}}{\emph{name}}{}
Convert CamelCase to space separated text.

\end{fulllineitems}

\index{cpp\_comment() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.cpp_comment}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{cpp\_comment}}{\emph{value}, \emph{indent=0}}{}
Split the input value in separate lines and indents each of them by `indent' spaces.

Every line is prepended by a comment delimiter (//).

\end{fulllineitems}

\index{dec() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.dec}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{dec}}{\emph{value}, \emph{dec=1}}{}
Decrement value by `dec'.

\end{fulllineitems}

\index{hex() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.hex}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{hex}}{\emph{value}, \emph{digits=4}}{}
Format the input value using `digits' in hexadecimal.

\end{fulllineitems}

\index{html\_comment() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.html_comment}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{html\_comment}}{\emph{value}, \emph{indent=0}}{}
Split the input value in separate lines and indents each of them by `indent' spaces.

The whole section is prefixed and suffixed by comment delimiters (\textless{}!-- and --\textgreater{}).

\end{fulllineitems}

\index{html\_string() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.html_string}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{html\_string}}{\emph{value}}{}
Escape YAML (multi-line) string into html.

\end{fulllineitems}

\index{inc() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.inc}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{inc}}{\emph{value}, \emph{inc=1}}{}
Increment value by `inc'.

\end{fulllineitems}

\index{line\_comment() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.line_comment}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{line\_comment}}{\emph{value}, \emph{prefix}, \emph{indent=0}, \emph{suffix='`}}{}
Generate line comment.

\end{fulllineitems}

\index{list\_nodes\_and\_sequences() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.list_nodes_and_sequences}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{list\_nodes\_and\_sequences}}{\emph{node}, \emph{list=None}}{}
List the input group recursively.

A sequence is an end node. Children of groups agreed
listed, but children of sequences are not. This filter can be used to generate a top-level
list of registeres, referring to the output of list\_sequences.

\end{fulllineitems}

\index{list\_nodes\_recursively() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.list_nodes_recursively}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{list\_nodes\_recursively}}{\emph{node}, \emph{doc=False}, \emph{list=None}}{}
List the input group recursively.

Groups are listed before their children. Bitfield are NOT listed.
If `doc' is true, then registers with the `nodoc' attribute (sequences) are not in the list, but
an artificial group with name (...) is inserted where registers are left out. The latter is used
for documentation.

\end{fulllineitems}

\index{list\_sequences() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.list_sequences}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{list\_sequences}}{\emph{node}}{}
List the input group recursively.

Sequences and groups are listed before their children. Sequences are unwrapped, but only
listed once. Bitfield are NOT listed. This filter can be used to generate structs in C/C++.

\end{fulllineitems}

\index{multi\_line\_comment() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.multi_line_comment}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{multi\_line\_comment}}{\emph{value}, \emph{prefix}, \emph{postfix}, \emph{indent=0}}{}
Generate multi-line comment.

\end{fulllineitems}

\index{prepend() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.prepend}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{prepend}}{\emph{value}, \emph{prefix}}{}
Format the input value as prefix\sphinxstyleemphasis{value}.

\end{fulllineitems}

\index{semi() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.semi}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{semi}}{\emph{field}, \emph{semi=True}}{}
Append a semicolon unless append = False.

\end{fulllineitems}

\index{tex\_comment() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.tex_comment}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{tex\_comment}}{\emph{value}, \emph{indent=0}}{}
Split the input value in separate lines and indents each of them by `indent' spaces.

Every line is prepended by a comment delimiter (\%).

\end{fulllineitems}

\index{tex\_escape() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.tex_escape}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{tex\_escape}}{\emph{value}}{}
Escape the input value for LaTeX.

\end{fulllineitems}

\index{tex\_string() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.tex_string}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{tex\_string}}{\emph{value}}{}
Escape YAML (multi-line) string into LaTeX and calls tex\_escape.

\end{fulllineitems}

\index{tex\_yaml\_encode() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.tex_yaml_encode}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{tex\_yaml\_encode}}{\emph{value}}{}
Encode the standard codes (see below) as codes used in a LaTeX template.

Use this filter for values of attributes set in the config file and used in a LaTeX
template.

\end{fulllineitems}

\index{version() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.version}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{version}}{\emph{value}}{}
Convert MajorVersion.MinorVersion to MajorVersion*0x100+MinorVersion.

\end{fulllineitems}

\index{vhdl\_comment() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.vhdl_comment}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{vhdl\_comment}}{\emph{value}, \emph{indent=0}}{}
Split the input value in separate lines and indents each of them by `indent' spaces.

Every line is prepended by a comment delimiter (--).

\end{fulllineitems}

\index{vhdl\_constant() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.vhdl_constant}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{vhdl\_constant}}{\emph{value}, \emph{bits=1}}{}
Format the input value using `bits' in binary of hexadecimal for VHDL.

\end{fulllineitems}

\index{vhdl\_downto() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.vhdl_downto}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{vhdl\_downto}}{\emph{bitfield}}{}
Format the input value as (\sphinxstyleemphasis{hi} downto \sphinxstyleemphasis{lo}).

\end{fulllineitems}

\index{vhdl\_logic\_vector() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.vhdl_logic_vector}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{vhdl\_logic\_vector}}{\emph{bitfield}}{}
Format the bitfield value as std\_logic\_vector(\sphinxstyleemphasis{hi} downto \sphinxstyleemphasis{lo}).

\end{fulllineitems}

\index{vhdl\_value() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.vhdl_value}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{vhdl\_value}}{\emph{bitfield}, \emph{prefix}}{}
Return vhdl value.

If the input value is a trigger, the input.value is returned (and must be
specified in the YAML file) either as String or as constant and will be vhdl
formatted.
If the input value is not a trigger, then vhdl\_downto is called
prepended by prefix.

\end{fulllineitems}

\index{xhex() (in module wuppercodegen.filter)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{developer:wuppercodegen.filter.xhex}}\pysiglinewithargsret{\sphinxcode{wuppercodegen.filter.}\sphinxbfcode{xhex}}{\emph{value}, \emph{digits=4}}{}
Format the input value as hexadecimal: 0x1F40. Specially for usage in latex where underscores do not work.

\end{fulllineitems}



\subsection{Codes for LaTeX (templates where the output ends in .tex)}
\label{\detokenize{developer:codes-for-latex-templates-where-the-output-ends-in-tex}}
As LaTeX uses a lot of special characters WupperCodeGen redefines
the standard JinJa2 delimeters to some others. Care must also be
taken in a LaTeX template to escape all texts. An escape\_tex filter
is available to handle this.

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\sphinxstylethead{\relax 
Delimiters
\unskip}\relax &\sphinxstylethead{\relax 
Standard
\unskip}\relax &\sphinxstylethead{\relax 
LaTeX
\unskip}\relax \\
\hline
Statements
&
\{\% ... \%\}
&
((* ... *))
\\
\hline
Expressions
&
\{\{ ... \}\}
&
((( ... )))
\\
\hline
Comments
&
\{\# ... \#\}
&
((= ... =))
\\
\hline
Line Statements
&
\#  ... \#\#
&\\
\hline\end{tabulary}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{w}
\item {\sphinxstyleindexentry{wuppercodegen.classes}}\sphinxstyleindexpageref{developer:\detokenize{module-wuppercodegen.classes}}
\item {\sphinxstyleindexentry{wuppercodegen.filter}}\sphinxstyleindexpageref{developer:\detokenize{module-wuppercodegen.filter}}
\item {\sphinxstyleindexentry{wuppercodegen.test}}\sphinxstyleindexpageref{developer:\detokenize{module-wuppercodegen.test}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}