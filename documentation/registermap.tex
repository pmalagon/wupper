% ***************************************************************************
% ***************************************************************************
% ***************************************************************************
% ***************************************************************************
% ***************************************************************************
% DO NOT EDIT THIS FILE
% 
% This file was generated from template '../documentation/registermap.tex.template'
% and register map registers-1.0.yaml, version 2.0
% by the script 'wuppercodegen', version: 0.8.0,
% using the following commandline:
% 
% ../software/wuppercodegen/wuppercodegen/cli.py registers-1.0.yaml ../documentation/registermap.tex.template ../documentation/registermap.tex
% 
% Please do NOT edit this file, but edit the source file at '../documentation/registermap.tex.template'
% 
% ***************************************************************************
% ***************************************************************************
% ***************************************************************************
% ***************************************************************************
% ***************************************************************************

\section{WUPPER register map, version 2.0}
\label{App:Regmap}
Starting from the offset address of BAR0, BAR1 and BAR2, the register map for BAR0 expands from 0x0000 to 0x0430 for the PCIe control registers. BAR0 only contains registers associated with DMA. The offset for BAR0 is usually 0xFBB00000.

\tabulinesep=^1.0mm_0.7mm
\begin{longtabu} to \textwidth {|X[1.7,l]|X[1.1,l]|X[0.9,l]|X[5.1,l]|X[1.3,l]|X[1.2,l]|X[5.0,l]|}
\hline
\textbf{Address} &\textbf{PCIe} &\multicolumn{2}{l|}{\textbf{Name/Field}} &\textbf{Bits} &{\textbf{Type}} &\textbf{Description} \\
\hline
\endhead

\multicolumn{7}{|c|}{Bar0} \\
\hline
\multicolumn{7}{|c|}{DMA\_DESC} \\
\hline
0x0000 & 0,1 & \multicolumn{5}{l|}{DMA\_DESC\_0} \\
\cline{3-7}
 & & & END\_ADDRESS & 127:64 & W & End Address \\
 & & & START\_ADDRESS & 63:0 & W & Start Address \\
\hline
0x0010 & 0,1 & \multicolumn{5}{l|}{DMA\_DESC\_0a} \\
\cline{3-7}
 & & & SW\_POINTER & 127:64 & W & Pointer controlled by the software, indicating read or write status for circular DMA \\
 & & & WRAP\_AROUND & 12 & W & Wrap around \\
 & & & FROMHOST & 11 & W & 1: fromHost/ 0: toHost \\
 & & & NUM\_WORDS & 10:0 & W & Number of 32 bit words \\
\hline
\multicolumn{7}{|c|}{\ldots} \\
\hline
0x00E0 & 0,1 & \multicolumn{5}{l|}{DMA\_DESC\_7} \\
\cline{3-7}
 & & & END\_ADDRESS & 127:64 & W & End Address \\
 & & & START\_ADDRESS & 63:0 & W & Start Address \\
\hline
0x00F0 & 0,1 & \multicolumn{5}{l|}{DMA\_DESC\_7a} \\
\cline{3-7}
 & & & SW\_POINTER & 127:64 & W & Pointer controlled by the software, indicating read or write status for circular DMA \\
 & & & WRAP\_AROUND & 12 & W & Wrap around \\
 & & & FROMHOST & 11 & W & 1: fromHost/ 0: toHost \\
 & & & NUM\_WORDS & 10:0 & W & Number of 32 bit words \\
\hline
\multicolumn{7}{|c|}{DMA\_DESC\_STATUS} \\
\hline
0x0200 & 0,1 & \multicolumn{5}{l|}{DMA\_DESC\_STATUS\_0} \\
\cline{3-7}
 & & & EVEN\_PC & 66 & R & Even address cycle PC \\
 & & & EVEN\_DMA & 65 & R & Even address cycle DMA \\
 & & & DESC\_DONE & 64 & R & Descriptor Done \\
 & & & FW\_POINTER & 63:0 & R & Pointer controlled by the firmwarre, indicating where the DMA is busy reading or writing \\
\hline
\multicolumn{7}{|c|}{\ldots} \\
\hline
0x0270 & 0,1 & \multicolumn{5}{l|}{DMA\_DESC\_STATUS\_7} \\
\cline{3-7}
 & & & EVEN\_PC & 66 & R & Even address cycle PC \\
 & & & EVEN\_DMA & 65 & R & Even address cycle DMA \\
 & & & DESC\_DONE & 64 & R & Descriptor Done \\
 & & & FW\_POINTER & 63:0 & R & Pointer controlled by the firmwarre, indicating where the DMA is busy reading or writing \\
\hline
0x0300 & 0,1 & \multicolumn{2}{l|}{BAR0\_VALUE} &
31:0 & R & Copy of BAR0 offset reg. \\
\hline
0x0310 & 0,1 & \multicolumn{2}{l|}{BAR1\_VALUE} &
31:0 & R & Copy of BAR1 offset reg. \\
\hline
0x0320 & 0,1 & \multicolumn{2}{l|}{BAR2\_VALUE} &
31:0 & R & Copy of BAR2 offset reg. \\
\hline
0x0400 & 0,1 & \multicolumn{2}{l|}{DMA\_DESC\_ENABLE} &
7:0 & W & Enable descriptors 7:0. One bit per descriptor. Cleared when Descriptor is handled. \\
\hline
0x0410 & 0,1 & \multicolumn{2}{l|}{DMA\_FIFO\_FLUSH} &
any & T & Flush (reset). Any write clears the DMA Main output FIFO \\
\hline
0x0420 & 0,1 & \multicolumn{2}{l|}{DMA\_RESET} &
any & T & Reset Wupper Core (DMA Controller FSMs) \\
\hline
0x0430 & 0,1 & \multicolumn{2}{l|}{SOFT\_RESET} &
any & T & Global Software Reset. Any write resets applications, e.g. the Central Router. \\
\hline
0x0440 & 0,1 & \multicolumn{2}{l|}{REGISTER\_RESET} &
any & T & Resets the register map to default values. Any write triggers this reset. \\
\hline
0x0450 & 0,1 & \multicolumn{5}{l|}{FROMHOST\_FULL\_THRESH} \\
\cline{3-7}
 & & & THRESHOLD\_ASSERT & 22:16 & W & Assert value of the FromHost programmable full flag \\
 & & & THRESHOLD\_NEGATE & 6:0 & W & Negate value of the FromHost programmalbe full flag \\
\hline
0x0460 & 0,1 & \multicolumn{5}{l|}{TOHOST\_FULL\_THRESH} \\
\cline{3-7}
 & & & THRESHOLD\_ASSERT & 27:16 & W & Assert value of the ToHost programmable full flag \\
 & & & THRESHOLD\_NEGATE & 11:0 & W & Negate value of the ToHost programmalbe full flag \\
\hline
0x0470 & 0,1 & \multicolumn{2}{l|}{BUSY\_THRESHOLD\_ASSERT} &
63:0 & W & Tohost or Fromhost busy will be asserted in circular DMA mode when the server PC buffer gets full (space below ASSERT threshold).. \\
\hline
0x0480 & 0,1 & \multicolumn{2}{l|}{BUSY\_THRESHOLD\_NEGATE} &
63:0 & W & Tohost or Fromhost busy will be negated in circular DMA mode when the server PC buffer gets less full (space above NEGATE threshold). \\
\hline
0x0490 & 0,1 & \multicolumn{5}{l|}{BUSY\_STATUS} \\
\cline{3-7}
 & & & FROMHOST\_BUSY & 1 & R & A fromhost descriptor passed BUSY\_THRESHOLD\_ASSERT, busy flag set \\
 & & & TOHOST\_BUSY & 0 & R & A tohost descriptor passed BUSY\_THRESHOLD\_ASSERT, busy flag set \\
\hline
\caption{FELIX register map BAR0}\label{tab:dma_register_map_bar0} \\
\end{longtabu}

\newpage
BAR1 stores registers associated with the Interrupt vector. The offset for BAR1 is usually 0xFBA00000.

\begin{longtabu} to \textwidth {|X[1.7,l]|X[1.1,l]|X[0.9,l]|X[5.1,l]|X[1.3,l]|X[1.2,l]|X[5.0,l]|}
\hline
\textbf{Address} &\textbf{PCIe} &\multicolumn{2}{l|}{\textbf{Name/Field}} &\textbf{Bits} &{\textbf{Type}} &\textbf{Description} \\
\hline
\endhead

\multicolumn{7}{|c|}{Bar1} \\
\hline
\multicolumn{7}{|c|}{INT\_VEC} \\
\hline
0x0000 & 0,1 & \multicolumn{5}{l|}{INT\_VEC\_0} \\
\cline{3-7}
 & & & INT\_CTRL & 127:96 & W & Interrupt Control \\
 & & & INT\_DATA & 95:64 & W & Interrupt Data \\
 & & & INT\_ADDRESS & 64:0 & W & Interrupt Address \\
\hline
\multicolumn{7}{|c|}{\ldots} \\
\hline
0x00F0 & 0,1 & \multicolumn{5}{l|}{INT\_VEC\_15} \\
\cline{3-7}
 & & & INT\_CTRL & 127:96 & W & Interrupt Control \\
 & & & INT\_DATA & 95:64 & W & Interrupt Data \\
 & & & INT\_ADDRESS & 64:0 & W & Interrupt Address \\
\hline
0x0100 & 0,1 & \multicolumn{2}{l|}{INT\_TAB\_ENABLE} &
7:0 & W & Interrupt Table enable\newline Selectively enable Interrupts\newline  \\
\hline
\caption{FELIX register map BAR1}\label{tab:dma_register_map_bar1} \\
\end{longtabu}
%\newpage


BAR2 stores registers for the control and monitor of HDL modules inside the FPGA other than Wupper. A portion of this register map's section is dedicated for control and monitor of devices outside the FPGA; as for example simple SPI and I2C devices. The offset for BAR2 is usually 0xFB900000.

%\begin{landscape}
\begin{longtabu} to \textwidth {|X[1.7,l]|X[1.1,l]|X[0.9,l]|X[5.1,l]|X[1.3,l]|X[1.2,l]|X[5.0,l]|}
\hline
\textbf{Address} &\textbf{PCIe} &\multicolumn{2}{l|}{\textbf{Name/Field}} &\textbf{Bits} &{\textbf{Type}} &\textbf{Description} \\
\hline
\endhead

\multicolumn{7}{|c|}{Bar2} \\
\hline
\multicolumn{7}{|c|}{Generic Board Information} \\
\hline
0x0000 & 0 & \multicolumn{2}{l|}{REG\_MAP\_VERSION} &
15:0 & R & Register Map Version, 2.0 formatted as 0x0200 \\
\hline
0x0010 & 0 & \multicolumn{2}{l|}{BOARD\_ID\_TIMESTAMP} &
39:0 & R & Board ID Date / Time in BCD format YYMMDDhhmm \\
\hline
0x0020 & 0 & \multicolumn{2}{l|}{BOARD\_ID\_SVN} &
15:0 & R & Board ID SVN Revision \\
\hline
0x0030 & 0 & \multicolumn{2}{l|}{GIT\_COMMIT\_TIME} &
39:0 & R & Board ID GIT Commit time of current revision, Date / Time in BCD format YYMMDDhhmm \\
\hline
0x0040 & 0 & \multicolumn{2}{l|}{GIT\_TAG} &
63:0 & R & String containing the current GIT TAG \\
\hline
0x0050 & 0 & \multicolumn{2}{l|}{GIT\_COMMIT\_NUMBER} &
31:0 & R & Number of GIT commits after current GIT\_TAG \\
\hline
0x0060 & 0 & \multicolumn{2}{l|}{GIT\_HASH} &
31:0 & R & Short GIT hash (32 bit) \\
\hline
0x0070 & 0 & \multicolumn{2}{l|}{STATUS\_LEDS} &
7:0 & W & Board GPIO Leds \\
\hline
0x0080 & 0 & \multicolumn{5}{l|}{GENERIC\_CONSTANTS} \\
\cline{3-7}
 & & & INTERRUPTS & 15:8 & R & Number of Interrupts \\
 & & & DESCRIPTORS & 7:0 & R & Number of Descriptors \\
\hline
0x0090 & 0 & \multicolumn{2}{l|}{CARD\_TYPE} &
63:0 & R & Card Type:\newline   - 709 (0x2c5): VC-709\newline   - 710 (0x2c6): HTG-710\newline   - 711 (0x2c7): BNL-711\newline   - 712 (0x2c8): BNL-712\newline  \\
\hline
\multicolumn{7}{|c|}{Application Specific} \\
\hline
0x1000 & 0,1 & \multicolumn{2}{l|}{LFSR\_SEED\_0} &
63:0 & W & Least significant 64 bits of the LFSR seed \\
\hline
0x1010 & 0,1 & \multicolumn{2}{l|}{LFSR\_SEED\_1} &
63:0 & W & Bits 127 downto 64 of the LFSR seed \\
\hline
0x1020 & 0,1 & \multicolumn{2}{l|}{LFSR\_SEED\_2} &
63:0 & W & Bits 191 downto 128 of the LFSR seed \\
\hline
0x1030 & 0,1 & \multicolumn{2}{l|}{LFSR\_SEED\_3} &
63:0 & W & Bits 255 downto 192 of the LFSR seed \\
\hline
0x1040 & 0,1 & \multicolumn{2}{l|}{APP\_MUX} &
0:0 & W & Switch between multiplier or LFSR.\newline   * 0 LFSR\newline   * 1 Loopback\newline  \\
\hline
0x1050 & 0,1 & \multicolumn{2}{l|}{LFSR\_LOAD\_SEED} &
any & T & Writing any value to this register triggers the LFSR module to reset to the LFSR\_SEED value \\
\hline
0x1060 & 0,1 & \multicolumn{2}{l|}{APP\_ENABLE} &
0:0 & W & 1 Enables LFSR module or Loopback (depending on APP\_MUX)\newline 0 disable application\newline  \\
\hline
\multicolumn{7}{|c|}{House Keeping Controls And Monitors} \\
\hline
0x2300 & 0 & \multicolumn{2}{l|}{MMCM\_MAIN\_PLL\_LOCK} &
0 & R & Main MMCM PLL Lock Status \\
\hline
0x2310 & 0 & \multicolumn{5}{l|}{I2C\_WR} \\
\cline{3-7}
 & & & I2C\_WREN & any & T & Any write to this register triggers an I2C read or write sequence \\
 & & & I2C\_FULL & 25 & R & I2C FIFO full \\
 & & & WRITE\_2BYTES & 24 & W & Write two bytes \\
 & & & DATA\_BYTE2 & 23:16 & W & Data byte 2 \\
 & & & DATA\_BYTE1 & 15:8 & W & Data byte 1 \\
 & & & SLAVE\_ADDRESS & 7:1 & W & Slave address \\
 & & & READ\_NOT\_WRITE & 0 & W & READ/<o>WRITE</o> \\
\hline
0x2320 & 0 & \multicolumn{5}{l|}{I2C\_RD} \\
\cline{3-7}
 & & & I2C\_RDEN & any & T & Any write to this register pops the last I2C data from the FIFO \\
 & & & I2C\_EMPTY & 8 & R & I2C FIFO Empty \\
 & & & I2C\_DOUT & 7:0 & R & I2C READ Data \\
\hline
0x2330 & 0 & \multicolumn{2}{l|}{FPGA\_CORE\_TEMP} &
11:0 & R & XADC temperature monitor for the FPGA CORE\newline for Virtex7\newline temp (C)= ((FPGA\_CORE\_TEMP* 503.975)/4096)-273.15\newline for Kintex Ultrascale\newline temp (C)= ((FPGA\_CORE\_TEMP* 502.9098)/4096)-273.8195\newline  \\
\hline
0x2340 & 0 & \multicolumn{2}{l|}{FPGA\_CORE\_VCCINT} &
11:0 & R & XADC voltage measurement VCCINT = (FPGA\_CORE\_VCCINT *3.0)/4096 \\
\hline
0x2350 & 0 & \multicolumn{2}{l|}{FPGA\_CORE\_VCCAUX} &
11:0 & R & XADC voltage measurement VCCAUX = (FPGA\_CORE\_VCCAUX *3.0)/4096 \\
\hline
0x2360 & 0 & \multicolumn{2}{l|}{FPGA\_CORE\_VCCBRAM} &
11:0 & R & XADC voltage measurement VCCBRAM = (FPGA\_CORE\_VCCBRAM *3.0)/4096 \\
\hline
0x2370 & 0,1 & \multicolumn{2}{l|}{FPGA\_DNA} &
63:0 & R & Unique identifier of the FPGA \\
\hline
0x2800 & 0 & \multicolumn{2}{l|}{INT\_TEST\_4} &
any & T & Fire a test MSIx interrupt \#4 \\
\hline
0x2810 & 0 & \multicolumn{2}{l|}{INT\_TEST\_5} &
any & T & Fire a test MSIx interrupt \#5 \\
\hline
0x2820 & 0 & \multicolumn{5}{l|}{DMA\_BUSY\_STATUS} \\
\cline{3-7}
 & & & CLEAR\_LATCH & any & T & Any write to this register clears TOHOST\_BUSY\_LATCHED \\
 & & & ENABLE & 4 & W & Enable the DMA buffer on the server as a source of busy \\
 & & & TOHOST\_BUSY\_LATCHED & 3 & R & A tohost descriptor has passed BUSY\_THRESHOLD\_ASSERT in the past, busy flag was set \\
 & & & FROMHOST\_BUSY\_LATCHED & 2 & R & A fromhost descriptor has passed BUSY\_THRESHOLD\_ASSERT in the past, busy flag was set \\
 & & & FROMHOST\_BUSY & 1 & R & A fromhost descriptor passed BUSY\_THRESHOLD\_ASSERT, busy flag set \\
 & & & TOHOST\_BUSY & 0 & R & A tohost descriptor passed BUSY\_THRESHOLD\_ASSERT, busy flag set \\
\hline
\multicolumn{7}{|c|}{Wishbone} \\
\hline
0x4000 & 0 & \multicolumn{5}{l|}{WISHBONE\_CONTROL} \\
\cline{3-7}
 & & & WRITE\_NOT\_READ & 32 & W & wishbone write command wishbone read command \\
 & & & ADDRESS & 31:0 & W & Slave address for Wishbone bus \\
\hline
0x4010 & 0 & \multicolumn{5}{l|}{WISHBONE\_WRITE} \\
\cline{3-7}
 & & & WRITE\_ENABLE & any & T & Any write to this register triggers a write to the Wupper to Wishbone fifo \\
 & & & FULL & 32 & R & Wishbone \\
 & & & DATA & 31:0 & W & Wishbone \\
\hline
0x4020 & 0 & \multicolumn{5}{l|}{WISHBONE\_READ} \\
\cline{3-7}
 & & & READ\_ENABLE & any & T & Any write to this register triggers a read from the Wishbone to Wupper fifo \\
 & & & EMPTY & 32 & R & Indicates that the Wishbone to Wupper fifo is empty \\
 & & & DATA & 31:0 & R & Wishbone read data \\
\hline
0x4030 & 0 & \multicolumn{5}{l|}{WISHBONE\_STATUS} \\
\cline{3-7}
 & & & INT & 4 & R & interrupt \\
 & & & RETRY & 3 & R & Interface is not ready to accept data cycle should be retried \\
 & & & STALL & 2 & R & When pipelined mode slave can't accept additional transactions in its queue \\
 & & & ACKNOWLEDGE & 1 & R & Indicates the termination of a normal bus cycle \\
 & & & ERROR & 0 & R & Address not mapped by the crossbar \\
\hline
\caption{FELIX register map BAR2}\label{tab:dma_register_map_bar2} \\
\end{longtabu}
%\end{landscape}

\newpage